{"version":3,"sources":["src/utils.js"],"names":[],"mappings":";;;;IAyDiB,GAAG,2BAAb,SAAU,GAAG,CAAE,CAAC;wBAEV,CAAC;;;;aADR,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;;;;oBACA,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;;;;;;AAAnB,SAAC;aACJ,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;;;;;eACf,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;;;;KAJN,GAAG;CAQnB;;;;QA5De,OAAO,GAAP,OAAO;;;;;QAUP,KAAK,GAAL,KAAK;;;;QAWL,OAAO,GAAP,OAAO;QA2BP,MAAM,GAAN,MAAM;QAIL,GAAG,GAAH,GAAG;IAxDR,EAAE,mCAAM,MAAM;;AAInB,SAAS,OAAO,CAAE,EAAE,EAAE;AAC3B,MAAI,CAAC,GAAG,EAAE,CAAA;AACV,MAAI,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAClC,KAAC,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;GACjB;AACD,SAAO,CAAC,CAAA;CACT,AAIM,SAAS,KAAK,CAAE,CAAC,EAAE;AACxB,MAAI,CAAC,GAAG,SAAS,CAAA;AACjB,MAAI,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAChB,KAAC,GAAG,CAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAE,CAAA;GACvB,MAAM;AACL,KAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;GACjB;AACD,SAAO,CAAC,CAAA;CACT,AAGM,SAAS,OAAO,CAAE,CAAC,EAAE,IAAI,EAAE;AAChC,MAAI,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAA;AACvB,MAAI,IAAI,GAAG,EAAE,CAAA;;AAEb,MAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACpB,QAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAA;GAC1B;;AAED,MAAI,CAAC,GAAG,CAAC,CAAA;AACT,MAAI,CAAC,GAAG,SAAS,CAAA;AACjB,SAAO,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AAClC,QAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;AAClB,OAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;KACT,MAAM;AACL,WAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;AAChB,YAAK;KACN;GACF;;;AAGD,SAAO,CAAC,EAAE,CAAC,IAAI,CAAE,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAE,EAAE;AAClC,QAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;GAChB;;AAED,SAAO,CAAE,CAAC,EAAE,IAAI,CAAE,CAAA;CACnB;;AAEM,SAAS,MAAM,CAAE,CAAC,EAAE;AACzB,SAAO,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,CAAE,CAAA;CACpC","file":"src/utils.js","sourcesContent":["\nimport * as is from './is'\n\n// Decode query key from '_$foo' -> '$foo'. Encoding allows to refer to document\n// attributes which would conflict with ops.\nexport function decoded (qk) {\n  let r = qk\n  if (qk[0] === '_' && qk[1] === '$') {\n    r = qk.substr(1)\n  }\n  return r\n}\n\n// Arrize path by splitting 'foo.bar' -> [ 'foo', 'bar' ], unless string starts\n// with ' ' then ' foo.bar' -> [ 'foo.bar' ].\nexport function split (a) {\n  let r = undefined\n  if (a[0] === ' ') {\n    r = [ a.substring(1) ]\n  } else {\n    r = a.split('.')\n  }\n  return r\n}\n\n// Resolve key path on an object.\nexport function resolve (a, path) {\n  let stack = split(path)\n  let last = []\n\n  if (stack.length > 0) {\n    last.unshift(stack.pop())\n  }\n\n  let e = a\n  let k = undefined\n  while (!is.none(k = stack.shift())) {\n    if (!is.none(e[k])) {\n      e = e[k]\n    } else {\n      stack.unshift(k)\n      break\n    }\n  }\n\n  // Pull all unresolved components into last.\n  while (!is.none((k = stack.pop()))) {\n    last.unshift(k)\n  }\n\n  return [ e, last ]\n}\n\nexport function arrize (a) {\n  return Array.isArray(a) ? a : [ a ]\n}\n\nexport function* kvs (a) {\n  if (is.object(a)) {\n    for (let k of Object.keys(a)) {\n      if (a.hasOwnProperty(k)) {\n        yield [k, a[k]]\n      }\n    }\n  }\n}\n"]}